# -*- coding: utf-8 -*-
"""Ass_v4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PGmYhB0iA6L7dWVfX9tgrjoKDJt20avY
"""

###################         Header          ############################
#
# Aluno: Rodolfo Augusto da Silva Arrda
# NUSP: 6381848
#
# Assignment 4: image restoration
#
# SCC0251/5830â€” Prof. Moacir A. Ponti
# Teaching Assistant: Leo Sampaio Ferraz Ribeiro
#
###################   Funcoes Auxiliares   ############################

################ F2D Denoising

def F2D_denoising(img_g,a,len_f,method,gamma):

	center = int(np.trunc(len_f/2))
	matriz_pad = np.pad(img_g,center,mode='symmetric')
	N,M = img_g.shape
	avg_l = np.zeros([N,M]).astype(float)
	std_l = np.zeros([N,M]).astype(float)

	## recortar imagem degradada
	img_g_crop = img_g[int(a[0]):int(a[1]),int(a[2]):int(a[3])]
	
	if method == "average":
		# media geral 
		std_n = np.std(img_g_crop)
		# media central 
		for i in range(M):
			for j in range(N):
				avg_l[i,j] = np.average(matriz_pad[i:i+len_f,j:j+len_f])
				std_l[i,j] = np.std(matriz_pad[i:i+len_f,j:j+len_f])
				if std_l[i,j] == 0:	std_l[i,j] = 1
				if std_n == 0: std_n = std_l[i,j]

				
	elif method == "robust":
		# media geral 
		std_n = np.percentile(img_g_crop,75) - np.percentile(img_g_crop,25)
		# media central
		for i in range(M):
			for j in range(N):
				avg_l[i,j] = np.median(matriz_pad[i:i+len_f,j:j+len_f])
				std_l[i,j] = np.percentile(matriz_pad[i:i+len_f,j:j+len_f],75) - np.percentile(matriz_pad[i:i+len_f,j:j+len_f],25)
				if std_l[i,j] == 0:	std_l[i,j] = 1
				if std_n == 0: std_n = std_l[i,j]

	return (img_g - gamma*(std_n/std_l)*(img_g - avg_l))


################ F2D Constrained Least Squares Filtering (CLS)


##### Gaussian Filter
def gaussian_filter( k, sigma):
	arx = np.arange((-k // 2) + 1.0 , ( k // 2) + 1.0 )
	x , y = np.meshgrid( arx , arx )
	filt = np.exp(-(1/2)*(np.square(x) + np.square( y ) ) / np.square( sigma ) )
	return filt /np.sum( filt )

##### CLS

def F2D_CLS(img_g,len_f,sigma,gamma):
	
	#Laplacian filter
	P = np.matrix([[0, -1 , 0], [-1, 4,-1], [0, -1 , 0]])
	# padding
	a1 = int(img_g.shape[0] // 2 - P.shape[0] // 2)
	P_pad = np.pad(P,(a1,a1-1),'constant',constant_values = (0))
	Pf      = rfft2(P_pad)
	#Pf_nornm = np.linalg.norm(Pf)**2    
	Pf_nornm = Pf**2  

	#Gaussian filter
	H = gaussian_filter(len_f,sigma)	
	a2 = int(img_g.shape[0] // 2 - H.shape[0] // 2)
	H_pad = np.pad(H,(a2,a2-1),'constant',constant_values = (0))
	Hf      = rfft2(H_pad)
	Hf_conj = np.conj(Hf)
	#Hf_nornm = np.linalg.norm(Hf)**2
	Hf_nornm = Hf**2
    
    
	# Fator que normaliza o Hf conjugado
	fator =  Hf_conj / (Hf_nornm + gamma*Pf_nornm) 
	
	# Imagem degradada no dominio da frequencia
	Gf = rfft2(img_g)
	
	AAA = np.multiply(fator,Gf)
    
	#inverse transform
	#G = fftshift(irfft2(AAA).real)
	G = fftshift(irfft2(AAA))
    
    
	return G


#######################################################################  

if __name__ == "__main__":
	import numpy as np
	import imageio
	import sys
	from scipy.fft import rfft2
	from scipy.fft import irfft2
	from scipy.fft import fftshift
	
	imf    = input().rstrip()
	img    = input().rstrip()
	F      = int(input().rstrip())
	gamma  = float(input().rstrip())
	a      = np.array((input().rstrip().split()))
	b      = input().rstrip()
	
	try:
		c      = input().rstrip()
	except EOFError as e:
		c = 0
	
	
	
	#load images
	## referencia
	#img_f = imageio.imread('C:\\Users\\rodol\\Desktop\\ass4\\InputImages\\' + imf)
	img_f = imageio.imread(imf)
	## degradada
	#img_g = imageio.imread('C:\\Users\\rodol\\Desktop\\ass4\\InputImages\\' + img)
	img_g = imageio.imread(img)
	
	if F == 1:

		f_hat  = np.clip(F2D_denoising(img_g,a,int(b),c,gamma),0,255)
          
	elif F == 2:
		
		f_hat  = np.clip(F2D_CLS(img_g,float(a),float(b),gamma),0,255)
		
	N,M = img_f.shape
	
	Erro = np.round(np.sqrt(np.sum((img_f.astype(float)-f_hat.astype(float))**2)/(N*M)),4)
	# Resultado Esperado
	print(Erro)

	
	
	
	


